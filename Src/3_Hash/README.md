# 哈希表

1. [0242\_有效的字母异位词](https://leetcode.cn/problems/valid-anagram/)--[code](./0242_ValidAnagram.cpp):

   给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

   示例 1: 输入: s = "anagram", t = "nagaram" 输出: true

   示例 2: 输入: s = "rat", t = "car" 输出: false

   说明: 你可以假设字符串只包含小写字母。

   - 解题思路：题目只有小写字母，可以定义一个数组使用桶方法记录出现过的字母，对比字符串删除出现过的字母，最后比对桶是否为空即可知道字母是否都相同。

   ![sample](https://code-thinking.cdn.bcebos.com/gifs/242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.gif)

2. [0349\_两个数组的交集](https://leetcode.cn/problems/intersection-of-two-arrays/)--[code](./0349_IntersectionOfTwoArrays.cpp):

   给定两个数组 nums1 和 nums2 ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。

   ```text
   1 <= nums1.length, nums2.length <= 1000
   0 <= nums1[i], nums2[i] <= 1000

   -----------------------------

   输入：nums1 = [1,2,2,1], nums2 = [2,2]
   输出：[2]

   -----------------------------

   输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
   输出：[9,4]
   解释：[4,9] 也是可通过的
   ```

   - 解题思路：**输出结果中的每个元素一定是唯一的，也就是说输出的结果的去重的， 同时可以不考虑输出结果的顺序**，由于限制了数组内数组大小，可以尝试用桶数组进行，也可以使用 unordered_set 去重。

3. [0202\_快乐数](https://leetcode.cn/problems/happy-number/description/)--[code](./0202_HappyNumber.cpp):

   编写一个算法来判断一个数 n 是不是快乐数。

   「快乐数」 定义为：

   对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
   然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。
   如果这个过程 结果为 1，那么这个数就是快乐数。
   如果 n 是 快乐数 就返回 true ；不是，则返回 false 。

   ```test
   输入：n = 19
   输出：true
   解释：
   12 + 92 = 82
   82 + 22 = 68
   62 + 82 = 100
   12 + 02 + 02 = 1

   -----------------------------

   输入：n = 2
   输出：false
   ```

   - 解题思路：题目中说了会 无限循环，那么也就是说求和的过程中，sum 会重复出现，这对解题很重要！
     - 当需要查找某个和是否已经出现过可以使用 unordered_set 进行去重保存。

4. [0001\_两数之和](https://leetcode.cn/problems/two-sum/description/)--[code](./0001_TwoSum.cpp):

   给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。

   你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

   你可以按任意顺序返回答案。

   ```test
   输入：nums = [2,7,11,15], target = 9
   输出：[0,1]
   解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。

   -----------------------------

   输入：nums = [3,2,4], target = 6
   输出：[1,2]

   -----------------------------

   输入：nums = [3,3], target = 6
   输出：[0,1]
   ```

   - 解题思路：与上一题类似，需要记录之前的结果状态，不过还要记录下前一个位置，因此 set 不再合适，需要用 map 来成对记录。

5. [0454_4 数之和](https://leetcode.cn/problems/4sum-ii/)--[code](./0454_4SumII.cpp):

   给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：

   0 <= i, j, k, l < n
   nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0

   ```text
   输入：nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]
   输出：2
   解释：
   两个元组如下：
   1. (0, 0, 0, 1) -> nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0
   2. (1, 1, 0, 0) -> nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0
   ```

   - 解题思路：由于本体不需要考虑有重复的四个元素相加等于 0 的情况，所以直接通过 map 记录前两个数组之和，然后计算后两个数组和时在 map 中查找需要的即可。

6. [0383\_赎金信](https://leetcode.cn/problems/ransom-note/description/)--[code](./0383_RansomNote.cpp):

   给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。

   如果可以，返回 true ；否则返回 false 。

   magazine 中的每个字符只能在 ransomNote 中使用一次。

   ```test
   输入：ransomNote = "a", magazine = "b"
   输出：false

   -----------------------------------------

   输入：ransomNote = "aa", magazine = "ab"
   输出：false

   -----------------------------------------

   输入：ransomNote = "aa", magazine = "aab"
   输出：true
   ```

   - 解题思路：本题判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成，但是这里需要注意两点：
     1. 杂志字符串中的字母不能重复使用；
     2. 只有小写字母。
   - 包含以上两点就可以放心使用桶来记录出现过的字母，因为只有 26 个不用操心存放的问题。

7. [0015\_三数之和](https://leetcode.cn/problems/3sum/)--[code](./0015_3Sum.cpp):

   给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请

   你返回所有和为 0 且不重复的三元组。

   注意：答案中不可以包含重复的三元组。

   ```test

   输入：nums = [-1,0,1,2,-1,-4]
   输出：[[-1,-1,2],[-1,0,1]]
   解释：
   nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。
   nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。
   nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。
   不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。
   注意，输出的顺序和三元组的顺序并不重要。

   -----------------------------------------

   输入：nums = [0,1,1]
   输出：[]
   解释：唯一可能的三元组和不为 0 。

   -----------------------------------------

   输入：nums = [0,0,0]
   输出：[[0,0,0]]
   解释：唯一可能的三元组和为 0 。
   ```

   - 解题思路：此题困难点在于不能包含重复的三元组，因此需要谨慎考虑边界条件，通过双指针可以不重复的遍历所有元素如下图：
     ![sample](https://code-thinking.cdn.bcebos.com/gifs/15.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.gif)

   - 基本步骤如下：
     1. 首先排序数组，找到退出边界，即当前节点 i > 0，这时无论如何也没法相加为 0 了。需要注意 i 去重。
     2. 定义 left、right 下标，通过判断相加情况移动节点，尝试找到和为 0 的情况。

8. [0018\_四数之和](https://leetcode.cn/problems/4sum/description/)--[code](./0018_4Sum.cpp):

   给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：

   0 <= a, b, c, d < n
   a、b、c 和 d 互不相同
   nums[a] + nums[b] + nums[c] + nums[d] == target
   你可以按 任意顺序 返回答案 。

   ```test
   输入：nums = [1,0,-1,0,-2,2], target = 0
   输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]

   -------------------------------------------

   输入：nums = [2,2,2,2,2], target = 8
   输出：[[2,2,2,2]]
   ```

   - 解题思路：与 三数之和 思路一致，大体是在其基础上增加一层 for 循环，具体区别如下：
     1. 分支裁剪时外层与内层有区别；
     2. 两层 for 循环 nums[k] + nums[i]为确定值，循环内使用双指针操作；
     3. 时间复杂度，三指针 O(n^2)，四指针 O(n^3)，以此类推。
